## 函数参数  
如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。  
形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。  
当调用函数时，有三种向函数传递参数的方式：  
1. 传值调用  
该方法**把参数的实际值赋值给函数的形式参数**。在这种情况下，修改函数内的形式参数对实际参数没有影响。  
```c++
void swap(int x, int y)
{
   int temp;
 
   temp = x; /* 保存 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 x 赋值给 y */
  
   return;
}
```  
2. 该方法**把参数的地址赋值给形式参数**。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。  
按指针传递值，参数指针被传递给函数，就像传递其他值给函数一样。  
```c++
void swap(int *x, int *y)
{
   int temp;
   temp = *x;    /* 保存地址 x 的值 */
   *x = *y;        /* 把 y 赋值给 x */
   *y = temp;    /* 把 x 赋值给 y */
  
   return;
}
```    
3. 向函数传递参数的引用调用方法，**把引用的地址复制给形式参数**。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。按引用传递值，参数引用被传递给函数，就像传递其他值给函数一样。  
```c++
void swap(int &x, int &y)
{
   int temp;
   temp = x; /* 保存地址 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 x 赋值给 y  */
  
   return;
}
```  
4. C++中的参数传递方式：传值、传地址、传引用  
- 指针：指针是一个变量，只不过这个变量中存储的是一个地址，指向内存中的一个单元。
- 引用：引用和原变量是同一个东西，只不过是原变量的一个别名。  
```c++
    int a = 10;   定义一个整型变量a
    int *p = &a;  定义一个指向整型变量的指针变量p，该指针指向a的存储单元，即p的值是a存储单元的地址
    int &b = a;   定义一个整型变量a的引用，a和b是同一个东西，在内存中占用同一个存储单元
```    
5. 常引用  
```c++
int a = 10;
int &b = a;  等价于 int *const b = a;即引用是一个指针常量（又称常指针，即一个常量，其类型是指针）
常引用：const int &a=b;等价于const int * const a=b;不仅仅是a这个地址不可修改，而且其指向的内存空间也不可修改。
```  
6. 引用的使用场景  
- 给变量起别名
- 将引用作为函数的参数
- 函数返回值  
```c++
    // 值返回
    int Add(int _iLeft, int _iRight)
    {
    return _iLeft + _iRight;
    } 
    // 引用返回
    int& Add(int & _iLeft, int& _iRight)
    {
    int iResult = _iLeft + _iRight;
    return iResult;
    }
```  
## Lambda 函数与表达式
1. C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。  
Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。    
Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下: 
``` 
[capture](parameters) mutable ->return-type{statement}  
```    
-  [capture]：捕捉列表。捕捉列表总是出现在 lambda 表达式的开始处。事实上，[] 是 lambda 引出符。编译器根据该引出符判断接下来的代码是否是 lambda 函数。捕捉列表能够捕捉上下文中的变量供 lambda 函数使用。  
-  (parameters)：参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号 () 一起省略。  
-  mutable：mutable 修饰符。默认情况下，lambda 函数总是一个 const 函数，mutable 可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。  
- ->return_type：返回类型。用追踪返回类型形式声明函数的返回类型。出于方便，不需要返回值的时候也可以连同符号 -> 一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。  
-  {statement}：函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。  
2. **在Lambda表达式内可以访问当前作用域的变量**，即**捕捉**。这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：  
```c++
[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
```  
对于[=]或[&]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：
```c++
[this]() { this->someFunc(); }();
```





