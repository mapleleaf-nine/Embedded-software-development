1. 常量指针  
- 定义： 又叫常指针，可以理解为常量的指针，也即这个是指针，但指向的是个常量，这个常量是指针的值（地址），而不是地址指向的值。  
- 理解：
    - 常量指针指向的对象不能通过这个指针来修改，可是仍然可以通过原来的声明修改；
    - 常量指针可以被赋值为变量的地址，之所以叫常量指针，是限制了通过这个指针修改变量的值；
    - 指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址；  
    ```c++
    int const* p;  const int* p;
    ```
2. 指针常量  
- 定义：本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。
- 理解：
    - 它是个常量！
    - 指针所保存的地址可以改变，然而指针所指向的值却不可以改变；
    - 指针本身是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化；  
    ```c++
    int* const p;
    ```
3. 指向常量的常指针
- 定义：指向常量的指针常量就是一个常量，且它指向的对象也是一个常量。
- 理解：
    - 一个指针常量，指向的是一个指针对象；
    - 它指向的指针对象且是一个常量，即它指向的对象不能变化；   
    ```c++
    const int* const p;  
    ```  
4. 区别常量指针与指针常量  
- 看const离谁近，即从右往左看：  
```c++
int const* p;    //const修饰的是*p，即*p的内容不可通过p改变，但p不是const，p可以修改，*p不可修改；
const int* p;    //同上
int* const p;    //const修饰的是p，p是指针，p指向的地址不能修改，p不能修改，但*p可以修改；
```  
- 实例
```c++
//-------常量指针-------
const int *p1 = &a;
a = 300;     //OK,仍然可以通过原来的声明修改值，
//*p1 = 56;  //Error,*p1是const int的，不可修改，即常量指针不可修改其指向地址
p1 = &b;     //OK,指针还可以指向别处，因为指针只是个变量，可以随意指向；

//-------指针常量-------//
int*  const p2 = &a;
a = 500;     //OK,仍然可以通过原来的声明修改值，
*p2 = 400;   //OK,指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化
//p2 = &b;     //Error,因为p2是const 指针，因此不能改变p2指向的内容

//-------指向常量的常量指针-------//
const int* const p3 = &a;
//*p3 = 1;    //Error
//p3 = &b;    //Error
a = 5000;    //OK,仍然可以通过原来的声明修改值
```  
5. 空指针与野指针
- 空指针就是保存地址为空的指针，使用指针时必须先判断是否空指针  
- 野指针是在delete掉指针之后，没有置0，导致指针随意指向了一个内存地址，如果继续使用，会造成不可预知的内存错误。
另外指针的误用很容易造成BUG或者内存泄漏。  
- 实例：  
```c++
//-------空指针-------//
int *p4 = NULL;
//printf("%d",*p4); //运行Error，使用指针时必须先判断是否空指针

//-------野指针（悬浮、迷途指针）-------//
int *p5 = new int(5);
delete p5;
p5 = NULL; //一定要有这一步
printf("%d",*p5);  //隐藏bug，delete掉指针后一定要置0，不然指针指向位置不可控，运行中可导致系统挂掉

//-------指针的内存泄漏-------//
int *p6 = new int(6);
p6 = new int(7); //p6原本指向的那块内存尚未释放，结果p6又指向了别处，原来new的内存无法访问，也无法delete了，造成memory leak
```


